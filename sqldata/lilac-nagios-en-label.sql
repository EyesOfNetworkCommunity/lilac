REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'physical_html_path', 'This is the physical path where the HTML files for Nagios are kept on your workstation or server. Nagios assumes that the documentation and images files (used by the CGIs) are stored in subdirectories called docs/ and images/, respectively.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'url_html_path', 'If, when accessing Nagios via a web browser, you point to an URL like http://www.myhost.com/nagios, this value should be /nagios. Basically, its the path portion of the URL that is used to access the Nagios HTML pages.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'use_authentication', 'This option controls whether or not the CGIs will use the authentication and authorization functionality when determining what information and commands users have access to. I would strongly suggest that you use the authentication functionality for the CGIs. If you decide not to use authentication, make sure to remove the command CGI to prevent unauthorized users from issuing commands to Nagios. The CGI will not issue commands to Nagios if authentication is disabled, but I would suggest removing it altogether just to be on the safe side.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'default_user_name', 'Setting this variable will define a default username that can access the CGIs. This allows people within a secure domain (i.e., behind a firewall) to access the CGIs without necessarily having to authenticate to the web server. You may want to use this to avoid having to use basic authentication if you are not using a secure server, as basic authentication transmits passwords in clear text over the Internet.<br />\r\n<br />\r\n<b>Important:</b> Do not define a default username unless you are running a secure web server and are sure that everyone who has access to the CGIs has been authenticated in some manner! If you define this variable, anyone who has not authenticated to the web server will inherit all rights you assign to this user! ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'authorized_for_system_information', 'This is a comma-delimited list of names of authenticated users who can view system/process information in the extended information CGI. Users in this list are not automatically authorized to issue system/process commands. If you want users to be able to issue system/process commands as well, you must add them to the authorized_for_system_commands variable.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'authorized_for_system_commands', 'This is a comma-delimited list of names of authenticated users who can issue system/process commands via the command CGI. Users in this list are not automatically authorized to view system/process information. If you want users to be able to view system/process information as well, you must add them to the authorized_for_system_information variable. ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'authorized_for_configuration_information', 'This is a comma-delimited list of names of authenticated users who can view configuration information in the configuration CGI. Users in this list can view information on all configured hosts, host groups, services, contacts, contact groups, time periods, and commands.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'authorized_for_all_hosts', 'This is a comma-delimited list of names of authenticated users who can view status and configuration information for all hosts. Users in this list are also automatically authorized to view information for all services. Users in this list are not automatically authorized to issue commands for all hosts or services. If you want users able to issue commands for all hosts and services as well, you must add them to the authorized_for_all_host_commands variable.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'authorized_for_all_host_commands', 'This is a comma-delimited list of names of authenticated users who can issue commands for all hosts via the command CGI. Users in this list are also automatically authorized to issue commands for all services. Users in this list are not automatically authorized to view status or configuration information for all hosts or services. If you want users able to view status and configuration information for all hosts and services as well, you must add them to the authorized_for_all_hosts variable.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'authorized_for_all_services', 'This is a comma-delimited list of names of authenticated users who can view status and configuration information for all services. Users in this list are not automatically authorized to view information for all hosts. Users in this list are not automatically authorized to issue commands for all services. If you want users able to issue commands for all services as well, you must add them to the authorized_for_all_service_commands variable.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'authorized_for_all_service_commands', 'This is a comma-delimited list of names of authenticated users who can issue commands for all services via the command CGI. Users in this list are not automatically authorized to issue commands for all hosts. Users in this list are not automatically authorized to view status or configuration information for all hosts. If you want users able to view status and configuration information for all services as well, you must add them to the authorized_for_all_services variable.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'statusmap_background_image', 'This option allows you to specify an image to be used as a background in the statusmap CGI. It is assumed that the image resides in the HTML images path (i.e. /usr/local/nagios/share/images). This path is automatically determined by appending "/images" to the path specified by the physical_html_path directive. Note: The image file can be in GIF, JPEG, PNG, or GD2 format. However, GD2 format (preferably in uncompressed format) is recommended, as it will reduce the CPU load when the CGI generates the map image.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'default_statusmap_layout', 'This option allows you to specify the default layout method used by the statusmap CGI.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'statuswrl_include', 'This option allows you to include your own objects in the generated VRML world. It is assumed that the file resides in the path specified by the physical_html_path directive. Note: This file must be a fully qualified VRML world (i.e. you can view it by itself in a VRML browser).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'default_statuswrl_layout', 'This option allows you to specify the default layout method used by the statuswrl CGI.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'refresh_rate', 'This option allows you to specify the number of seconds between page refreshes for the status, statusmap, and extinfo CGIs.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'host_unreachable_sound', 'These options allow you to specify an audio file that should be played in your browser if there are problems when you are viewing the status CGI. If there are problems, the audio file for the most critical type of problem will be played. The most critical type of problem is on or more unreachable hosts, while the least critical is one or more services in an unknown state (see the order in the example above). Audio files are assumed to be in the media/ subdirectory in your HTML directory (i.e. /usr/local/nagios/share/media).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'ping_syntax', 'This option determines what syntax should be used when attempting to ping a host from the WAP interface (using the statuswml CGI. You must include the full path to the ping binary, along with all required options. The $HOSTADDRESS$ macro is substituted with the address of the host before the command is executed.');

REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'escape_html_tags', 'This option determines whether or not HTML tags in host and service (plugin) output is escaped in the CGIs. If you enable this option, your plugin output will not be able to contain clickable hyperlinks. ');

REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'lock_author_names', 'This option allows you to restrict users from changing the author name when submitting comments, acknowledgements, and scheduled downtime from the web interface. If this option is enabled, users will be unable to change the author name associated with the command request. ');

REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'notes_url_target', 'This option determines the name of the frame target that notes URLs should be displayed in. Valid options include _blank, _self, _top, _parent, or any other valid target name. ');

REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'action_url_target', 'This option determines the name of the frame target that action URLs should be displayed in. Valid options include _blank, _self, _top, _parent, or any other valid target name. ');

REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'enable_splunk_integration', 'This option determines whether integration functionality with Splunk is enabled in the web interface. If enabled, you\'ll be presented with "Splunk It" links in various places in the CGIs (log file, alert history, host/service detail, etc). Useful if you\'re trying to research why a particular problem occurred.');

REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'splunk_url', 'This option is used to define the base URL to your Splunk interface. This URL is used by the CGIs when creating links if the enable_splunk_integration option is enabled. ');

REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'nagios_check_command', 'This is an optional command that the CGIs can use to check the status of the Nagios process. This provides the CGIs (as well as yourself) with some idea of whether or not Nagios is still running. If you do not specify a command to be run, the CGIs will assume that the Nagios process is running. If you do define a process check command, it should follow the same guidelines that are required of standard plugins. If the command returns a non-OK status, the CGIs will think the Nagios process is not running and will refuse to allow you to commit any commands via the command CGI.');

REPLACE INTO `label`(section, name, label)  VALUES('nagios_commands_desc', 'command_name', 'This directive is the short name used to identify the command. It is referenced in contact, host, and service definitions, among other places.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_commands_desc', 'command_line', 'This directive is used to define what is actually executed by Nagios when the command is used for service or host checks, notifications, or event handlers. Before the command line is executed, all valid macros are replaced with their respective values. See the documentation on macros for determining when you can use different macros. Note that the command line is not surrounded in quotes. Also, if you want to pass a dollar sign ($) on the command line, you have to escape it with another dollar sign.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_commands_desc', 'command_desc', 'This is a description of the command.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contactgroups_desc', 'contactgroup_name', 'This directive is a short name used to identify the contact group.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contactgroups_desc', 'alias', 'This directive is used to define a longer name or description used to identify the contact group.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contactgroups_desc', 'members', 'This directive is used to define a list of the short names of contacts  that should be included in this group. Multiple contact names should be separated by commas.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contactgroups_desc', 'contactgroup_name', 'This directive is a short name used to identify the contact group.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contactgroups_desc', 'alias', 'This directive is used to define a longer name or description used to identify the contact group.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contactgroups_desc', 'members', 'This directive is used to define a list of the short names of contacts  that should be included in this group. Multiple contact names should be separated by commas.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contactgroups_desc', 'contactgroup_name', 'This directive is a short name used to identify the contact group.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contactgroups_desc', 'alias', 'This directive is used to define a longer name or description used to identify the contact group.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contactgroups_desc', 'members', 'This directive is used to define a list of the short names of contacts  that should be included in this group. Multiple contact names should be separated by commas.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contacts_desc', 'contact_name', 'This directive is used to define a short name used to identify the contact. It is referenced in contact group definitions. Under the right circumstances, the $CONTACTNAME$ macro will contain this value.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contacts_desc', 'alias', 'This directive is used to define a longer name or description for the contact. Under the rights circumstances, the $CONTACTALIAS$ macro will contain this value.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contacts_desc', 'host_notification_period', 'This directive is used to specify the short name of the time period during which the contact can be notified about host problems or recoveries. You can think of this as an "on call" time for host notifications for the contact. Read the documentation on time periods for more information on how this works and potential problems that may result from improper use.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contacts_desc', 'service_notification_period', 'This directive is used to specify the short name of the time period during which the contact can be notified about service problems or recoveries. You can think of this as an "on call" time for service notifications for the contact. Read the documentation on time periods for more information on how this works and potential problems that may result from improper use.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contacts_desc', 'host_notification_commands', 'This directive is used to define a list of the short names of the commands used to notify the contact of a host problem or recovery. Multiple notification commands should be separated by commas. All notification commands are executed when the contact needs to be notified. The maximum amount of time that a notification command can run is controlled by the notification_timeout option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contacts_desc', 'host_notification_options', 'This directive is used to define the host states for which notifications can be sent out to this contact.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contacts_desc', 'service_notification_options', 'This directive is used to define the service states for which notifications can be sent out to this contact.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contacts_desc', 'service_notification_commands', 'This directive is used to define a list of the short names of the commands used to notify the contact of a service problem or recovery. Multiple notification commands should be separated by commas. All notification commands are executed when the contact needs to be notified. The maximum amount of time that a notification command can run is controlled by the notification_timeout option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contacts_desc', 'email', 'This directive is used to define an email address for the contact. Depending on how you configure your notification commands, it can be used to send out an alert email to the contact. Under the right circumstances, the $CONTACTEMAIL$ macro will contain this value.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contacts_desc', 'pager', 'This directive is used to define a pager number for the contact. It can also be an email address to a pager gateway (i.e. pagejoe@pagenet.com). Depending on how you configure your notification commands, it can be used to send out an alert page to the contact. Under the right circumstances, the $CONTACTPAGER$ macro will contact this value.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_contacts_desc', 'address', 'Address directives are used to define additional "addresses" for the contact. These addresses can be anything - cell phone numbers, instant messaging addresses, etc. Depending on how you configure your notification commands, they can be used to send out an alert o the contact. Up to six addresses can be defined using these directives (address1 through address6). The $CONTACTADDRESSx$ macro will contain this value.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_dependency_desc', 'inherits_parent', 'This directive indicates whether or not the dependency inherits dependencies of the host that is being depended upon (also referred to as the master host). In other words, if the master host is dependent upon other hosts and any one of those dependencies fail, this dependency will also fail.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_dependency_desc', 'host_execution_failure_criteria', 'This directive is used to specify the criteria that determine when the dependent host should not be actively checked. If the master host is in one of the failure states we specify, the dependent host will not be actively checked. Valid options are a combination of one or more of the following (multiple options are seperated with commas): o = fail on an UP state, d = fail on a DOWN state, u = fail on an UNREACHABLE state, and p = fail on a pending state (e.g. the host has not yet been checked). If you specify n (none) as an option, the execution dependency will never fail and the dependent host will always be actively checked (if other conditions allow for it to be). Example: If you specify u,d in this field, the dependent host will not be actively checked if the master host is in either an UNREACHABLE or DOWN state.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_dependency_desc', 'service_execution_failure_criteria', '	This directive is used to specify the criteria that determine when the dependent service should not be actively checked. If the master service is in one of the failure states we specify, the dependent service will not be actively checked. Valid options are a combination of one or more of the following (multiple options are seperated with commas): o = fail on an OK state, w = fail on a WARNING state, u = fail on an UNKNOWN state, c = fail on a CRITICAL state, and p = fail on a pending state (e.g. the service has not yet been checked). If you specify n (none) as an option, the execution dependency will never fail and checks of the dependent service will always be actively checked (if other conditions allow for it to be). Example: If you specify o,c,u in this field, the dependent service will not be actively checked if the master service is in either an OK, a CRITICAL, or an UNKNOWN state.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_dependency_desc', 'service_notification_failure_criteria', 'This directive is used to define the criteria that determine when notifications for the dependent service should not be sent out. If the master service is in one of the failure states we specify, notifications for the dependent service will not be sent to contacts. Valid options are a combination of one or more of the following: o = fail on an OK state, w = fail on a WARNING state, u = fail on an UNKNOWN state, c = fail on a CRITICAL state, and p = fail on a pending state (e.g. the service has not yet been checked). If you specify n (none) as an option, the notification dependency will never fail and notifications for the dependent service will always be sent out. Example: If you specify w in this field, the notifications for the dependent service will not be sent out if the master service is in a WARNING state.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_dependency_desc', 'host_notification_failure_criteria', 'This directive is used to define the criteria that determine when notifications for the dependent host should not be sent out. If the master host is in one of the failure states we specify, notifications for the dependent host will not be sent to contacts. Valid options are a combination of one or more of the following: o = fail on an UP state, d = fail on a DOWN state, u = fail on an UNREACHABLE state, and p = fail on a pending state (e.g. the host has not yet been checked). If you specify n (none) as an option, the notification dependency will never fail and notifications for the dependent host will always be sent out. Example: If you specify d in this field, the notifications for the dependent host will not be sent out if the master host is in a DOWN state.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_escalations_desc', 'escalation_description', 'A description of the escalation.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_escalations_desc', 'first_notification', 'This directive is a number that identifies the first notification for which this escalation is effective. For instance, if you set this value to 3, this escalation will only be used if the host is down or unreachable long enough for a third notification to go out.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_escalations_desc', 'last_notification', 'This directive is a number that identifies the last notification for which this escalation is effective. For instance, if you set this value to 5, this escalation will not be used if more than five notifications are sent out for the host. Setting this value to 0 means to keep using this escalation entry forever (no matter how many notifications go out).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_escalations_desc', 'escalation_period', 'This directive is used to specify the short name of the time period during which this escalation is valid. If this directive is not specified, the escalation is considered to be valid during all times.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_escalations_desc', 'escalation_options', 'This directive is used to define the criteria that determine when this host escalation is used. The escalation is used only if the host is in one of the states specified in this directive. If this directive is not specified in a host escalation, the escalation is considered to be valid during all host states. Valid options are a combination of one or more of the following: r = escalate on an UP (recovery) state, d = escalate on a DOWN state, and u = escalate on an UNREACHABLE state. Example: If you specify d in this field, the escalation will only be used if the host is in a DOWN state.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_escalations_desc', 'notification_interval', 'This directive is used to determine the interval at which notifications should be made while this escalation is valid. If you specify a value of 0 for the interval, Nagios will send the first notification when this escalation definition is valid, but will then prevent any more problem notifications from being sent out for the host. Notifications are sent out again until the host recovers. This is useful if you want to stop having notifications sent out after a certain amount of time. Note: If multiple escalation entries for a host overlap for one or more notification ranges, the smallest notification interval from all escalation entries is used');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hostgroups_desc', 'hostgroup_name', 'This directive is used to define a short name used to identify the host group.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hostgroups_desc', 'alias', 'This directive is used to define is a longer name or description used to identify the host group. It is provided in order to allow you to more easily identify a particular host group.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hostgroups_desc', 'members', 'This is a list of the short names of hosts that should be included in this group. Multiple host names should be separated by commas.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hostgroups_desc', 'contact_groups', 'This is a list of the short names of the contact groups that should be notified whenever there are problems (or recoveries) with any of the hosts in this host group. Multiple contact groups should be separated by commas.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'host_name', 'This directive is used to define a short name used to identify the host. It is used in host group and service definitions to reference this particular host. Hosts can have multiple services (which are monitored) associated with them. When used properly, the $HOSTNAME$ macro will contain this short name.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'alias', 'This directive is used to define a longer name or description used to identify the host. It is provided in order to allow you to more easily identify a particular host. When used properly, the $HOSTALIAS$ macro will contain this alias/description.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'address', 'This directive is used to define the address of the host. Normally, this is an IP address, although it could really be anything you want (so long as it can be used to check the status of the host). You can use a FQDN to identify the host instead of an IP address, but if DNS services are not availble this could cause problems. When used properly, the $HOSTADDRESS$ macro will contain this address. Note: If you do not specify an address directive in a host definition, the name of the host will be used as its address. A word of caution about doing this, however - if DNS fails, most of your service checks will fail because the plugins will be unable to resolve the host name.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'check_command', 'This directive is used to specify the short name of the command that should be used to check if the host is up or down. Typically, this command would try and ping the host to see if it is "alive". The command must return a status of OK (0) or Nagios will assume the host is down. If you leave this argument blank, the host will not be checked - Nagios will always assume the host is up. This is useful if you are monitoring printers or other devices that are frequently turned off. The maximum amount of time that the notification command can run is controlled by the host_check_timeout option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'max_check_attempts', 'This directive is used to define the number of times that Nagios will retry the host check command if it returns any state other than an OK state. Setting this value to 1 will cause Nagios to generate an alert without retrying the host check again. Note: If you do not want to check the status of the host, you must still set this to a minimum value of 1. To bypass the host check, just leave the check_command option blank.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'checks_enabled', 'This directive is used to determine whether or not checks of this host are enabled.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'event_handler', 'This directive is used to specify the short name of the command that should be run whenever a change in the state of the host is detected (i.e. whenever it goes down or recovers). Read the documentation on event handlers for a more detailed explanation of how to write scripts for handling events. The maximum amount of time that the event handler command can run is controlled by the event_handler_timeout option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'event_handler_enabled', 'This directive is used to determine whether or not the event handler for this host is enabled. Values: 0 = disable host event handler, 1 = enable host event handler.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'low_flap_threshold', 'This directive is used to specify the low state change threshold used in flap detection for this host. If you set this directive to a value of 0, the program-wide value specified by the low_host_flap_threshold directive will be used.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'high_flap_threshold', 'This directive is used to specify the high state change threshold used in flap detection for this host. If you set this directive to a value of 0, the program-wide value specified by the high_host_flap_threshold directive will be used.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'flap_detection_enabled', 'This directive is used to determine whether or not flap detection is enabled for this host.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'process_perf_data', 'This directive is used to determine whether or not the processing of performance data is enabled for this host.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'retain_status_information', 'This directive is used to determine whether or not status-related information about the host is retained across program restarts. This is only useful if you have enabled state retention using the retain_state_information directive. ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'retain_nonstatus_information', 'This directive is used to determine whether or not non-status information about the host is retained across program restarts. This is only useful if you have enabled state retention using the retain_state_information directive.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'notification_interval', 'This directive is used to define the number of "time units" to wait before re-notifying a contact that this server is still down or unreachable. Unless you''ve changed the interval_length directive from the default value of 60, this number will mean minutes. If you set this value to 0, Nagios will not re-notify contacts about problems for this host - only one problem notification will be sent out.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'notification_period', 'This directive is used to specify the short name of the time period during which notifications of events for this host can be sent out to contacts. If a host goes down, becomes unreachable, or recoveries during a time which is not covered by the time period, no notifications will be sent out.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'notification_options', 'This directive is used to determine when notifications for the host should be sent out. Valid options are a combination of one or more of the following: d = send notifications on a DOWN state, u = send notifications on an UNREACHABLE state, and r = send notifications on recoveries (OK state). If you specify n (none) as an option, no host notifications will be sent out. Example: If you specify d,r in this field, notifications will only be sent out when the host goes DOWN and when it recovers from a DOWN state.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'notifications_enabled', 'This directive is used to determine whether or not notifications for this host are enabled.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'stalking_options', 'This directive determines which host states "stalking" is enabled for.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'check_interval', '<b>NOTE:</b> Do NOT enable regularly scheduled checks of a host unless you absolutely need to! Host checks are already performed on-demand when necessary, so there are few times when regularly scheduled checks would be needed. Regularly scheduled host checks can negatively impact performance - see the performance tuning tips for more information. This directive is used to define the number of "time units" between regularly scheduled checks of the host. Unless you''ve changed the interval_length directive from the default value of 60, this number will mean minutes.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'active_checks_enabled', 'This directive is used to determine whether or not active checks (either regularly scheduled or on-demand) of this host are enabled.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'passive_checks_enabled', 'This directive is used to determine whether or not passive checks are enabled for this host.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'obsess_over_host', 'This directive determines whether or not checks for the host will be "obsessed" over using the ochp_command.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'check_freshness', 'This directive is used to determine whether or not freshness checks are enabled for this host.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'freshness_threshold', 'This directive is used to specify the freshness threshold (in seconds) for this host. If you set this directive to a value of 0, Nagios will determine a freshness threshold to use automatically.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_desc', 'contact_groups', 'This is a list of the short names of the contact groups that should be notified whenever there are problems (or recoveries) with this host. Multiple contact groups should be separated by commas.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_extended_info_desc', 'notes', 'This directive is used to define an optional string of notes pertaining to the host. If you specify a note here, you will see the it in the extended information CGI (when you are viewing information about the specified host).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_extended_info_desc', 'notes_url', 'This variable is used to define an optional URL that can be used to provide more information about the host. If you specify an URL, you will see a link that says "Extra Host Notes" in the extended information CGI (when you are viewing information about the specified host). Any valid URL can be used. If you plan on using relative paths, the base path will the the same as what is used to access the CGIs (i.e. /cgi-bin/nagios/). This can be very useful if you want to make detailed information on the host, emergency contact methods, etc. available to other support staff.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_extended_info_desc', 'action_url', '	This directive is used to define an optional URL that can be used to provide more actions to be performed on the host. If you specify an URL, you will see a link that says "Extra Host Actions" in the extended information CGI (when you are viewing information about the specified host). Any valid URL can be used. If you plan on using relative paths, the base path will the the same as what is used to access the CGIs (i.e. /cgi-bin/nagios/).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_extended_info_desc', 'icon_image', 'This variable is used to define the name of a GIF, PNG, or JPG image that should be associated with this host. This image will be displayed in the status and extended information CGIs. The image will look best if it is 40x40 pixels in size. Images for hosts are assumed to be in the logos/ subdirectory in your HTML images directory (i.e. /usr/local/nagios/share/images/logos).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_extended_info_desc', 'icon_image_alt', 'This variable is used to define an optional string that is used in the ALT tag of the image specified by the <icon_image> argument. The ALT tag is used in the status, extended information and statusmap CGIs.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_extended_info_desc', 'vrml_image', 'This variable is used to define the name of a GIF, PNG, or JPG image that should be associated with this host. This image will be used as the texture map for the specified host in the statuswrl CGI. Unlike the image you use for the <icon_image> variable, this one should probably not have any transparency. If it does, the host object will look a bit wierd. Images for hosts are assumed to be in the logos/ subdirectory in your HTML images directory (i.e. /usr/local/nagios/share/images/logos).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_extended_info_desc', 'statusmap_image', 'This variable is used to define the name of an image that should be associated with this host in the statusmap CGI. You can specify a JPEG, PNG, and GIF image if you want, although I would strongly suggest using a GD2 format image, as other image formats will result in a lot of wasted CPU time when the statusmap image is generated. GD2 images can be created from PNG images by using the pngtogd2 utility supplied with Thomas Boutell''s gd library. The GD2 images should be created in uncompressed format in order to minimize CPU load when the statusmap CGI is generating the network map image. The image will look best if it is 40x40 pixels in size. You can leave these option blank if you are not using the statusmap CGI. Images for hosts are assumed to be in the logos/ subdirectory in your HTML images directory (i.e. /usr/local/nagios/share/images/logos).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_extended_info_desc', 'two_d_coords', 'This variable is used to define coordinates to use when drawing the host in the statusmap CGI. Coordinates should be given in positive integers, as the correspond to physical pixels in the generated image. The origin for drawing (0,0) is in the upper left hand corner of the image and extends in the positive x direction (to the right) along the top of the image and in the positive y direction (down) along the left hand side of the image. For reference, the size of the icons drawn is usually about 40x40 pixels (text takes a little extra space). The coordinates you specify here are for the upper left hand corner of the host icon that is drawn. Note: Don''t worry about what the maximum x and y coordinates that you can use are. The CGI will automatically calculate the maximum dimensions of the image it creates based on the largest x and y coordinates you specify.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_hosts_extended_info_desc', 'three_d_coords', 'This variable is used to define coordinates to use when drawing the host in the statuswrl CGI. Coordinates can be positive or negative real numbers. The origin for drawing is (0.0,0.0,0.0). For reference, the size of the host cubes drawn is 0.5 units on each side (text takes a little more space). The coordinates you specify here are used as the center of the host cube.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'config_dir', 'This is the location on the filesystem where you would like your nagios configuration files to be stored.  The webserver user MUST have write access to this directory and the files within.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_file', 'This variable specifies where Nagios should create its main log file. This should be the first variable that you define in your configuration file, as Nagios will try to write errors that it finds in the rest of your configuration data to this file. If you have log rotation enabled, this file will automatically be rotated every hour, day, week, or month.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'temp_file', 'This is a temporary file that Nagios periodically creates to use when updating comment data, status data, etc. The file is deleted when it is no longer needed.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'temp_path', 'This is path where Nagios can create temp files for service and host check results, etc.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'status_file', 'This is the file that Nagios uses to store the current status of all monitored services. The status of all hosts associated with the service you monitor are also recorded here. This file is used by the CGIs so that current monitoring status can be reported via a web interface. The CGIs must have read access to this file in order to function properly. This file is deleted every time Nagios stops and recreated when it starts.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'status_update_interval', 'This setting determines how often (in seconds) that Nagios will update status data in the status file. The minimum update interval is five seconds. If you have disabled aggregated status updates (with the aggregate_status_updates option), this option has no effect.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'nagios_user', 'This is used to set the effective user that the Nagios process should run as. After initial program startup and before starting to monitor anything, Nagios will drop its effective privileges and run as this user. You may specify either a username or a UID. ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'nagios_group', 'This is used to set the effective group that the Nagios process should run as. After initial program startup and before starting to monitor anything, Nagios will drop its effective privileges and run as this group. You may specify either a groupname or a GID.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'enable_notifications', 'This option determines whether or not Nagios will send out notifications when it initially (re)starts. If this option is disabled, Nagios will not send out notifications for any host or service. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you''ll have to use the appropriate external command or change it via the web interface.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'execute_service_checks', 'This option determines whether or not Nagios will execute service checks when it initially (re)starts. If this option is disabled, Nagios will not actively execute any service checks and will remain in a sort of "sleep" mode (it can still accept passive checks unless you''ve disabled them). This option is most often used when configuring backup monitoring servers, as described in the documentation on redundancy, or when setting up a distributed monitoring environment. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you''ll have to use the appropriate external command or change it via the web interface.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'accept_passive_service_checks', 'This option determines whether or not Nagios will accept passive service checks when it initially (re)starts. If this option is disabled, Nagios will not accept any passive service checks. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you''ll have to use the appropriate external command or change it via the web interface.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'enable_event_handlers', 'This option determines whether or not Nagios will run event handlers when it initially (re)starts. If this option is disabled, Nagios will not run any host or service event handlers. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you''ll have to use the appropriate external command or change it via the web interface.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_rotation_method', 'This is the rotation method that you would like Nagios to use for your log file.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_archive_path', 'This is the directory where Nagios should place log files that have been rotated. This option is ignored if you choose to not use the log rotation functionality.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'check_external_commands', 'This option determines whether or not Nagios will check the command file for internal commands it should execute. This option must be enabled if you plan on using the command CGI to issue commands via the web interface. Third party programs can also issue commands to Nagios by writing to the command file, provided proper rights to the file have been granted.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'external_command_buffer_slots', 'This setting is used to tweak the number of items or \'slots\' that the Nagios daemon should allocate to the buffer that holds incoming external commands before they are processed.  As external commands are processed by the daemon, they are removed from the buffer');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'command_check_interval', 'If you specify a number with an "s" appended to it (i.e. 30s), this is the number of seconds to wait between external command checks. If you leave off the "s", this is the number of "time units" to wait between external command checks. Unless you''ve changed the interval_length value (as defined below) from the default value of 60, this number will mean minutes.<br />\r\n<b>Note:</b> By setting this value to -1, Nagios will check for external commands as often as possible. Each time Nagios checks for external commands it will read and process all commands present in the command file before continuing on with its other duties.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'command_file', 'This is the file that Nagios will check for external commands to process. The command CGI writes commands to this file. Other third party programs can write to this file if proper file permissions have been granted as outline in here. The external command file is implemented as a named pipe (FIFO), which is created when Nagios starts and removed when it shuts down. If the file exists when Nagios starts, the Nagios process will terminate with an error message.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'lock_file', 'This option specifies the location of the lock file that Nagios should create when it runs as a daemon (when started with the -d command line argument). This file contains the process id (PID) number of the running Nagios process.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'retain_state_information', 'This option determines whether or not Nagios will retain state information for hosts and services between program restarts. If you enable this option, you should supply a value for the state_retention_file variable. When enabled, Nagios will save all state information for hosts and service before it shuts down (or restarts) and will read in previously saved state information when it starts up again.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'state_retention_file', 'This is the file that Nagios will use for storing service and host state information before it shuts down. When Nagios is restarted it will use the information stored in this file for setting the initial states of services and hosts before it starts monitoring anything. This file is deleted after Nagios reads in initial state information when it (re)starts. In order to make Nagios retain state information between program restarts, you must enable the retain_state_information option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'retention_update_interval', 'This setting determines how often (in minutes) that Nagios will automatically save retention data during normal operation. If you set this value to 0, Nagios will not save retention data at regular intervals, but it will still save retention data before shutting down or restarting. If you have disabled state retention (with the retain_state_information option), this option has no effect.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'use_retained_program_state', 'This setting determines whether or not Nagios will set various program-wide state variables based on the values saved in the retention file. Some of these program-wide state variables that are normally saved across program restarts if state retention is enabled include the enable_notifications, enable_flap_detection, enable_event_handlers, execute_service_checks, and accept_passive_service_checks options. If you do not have state retention enabled, this option has no effect.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'use_syslog', 'This variable determines whether messages are logged to the syslog facility on your local host.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_notifications', 'This variable determines whether or not notification messages are logged. If you have a lot of contacts or regular service failures your log file will grow relatively quickly. Use this option to keep contact notifications from being logged.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_service_retries', 'This variable determines whether or not service check retries are logged. Service check retries occur when a service check results in a non-OK state, but you have configured Nagios to retry the service more than once before responding to the error. Services in this situation are considered to be in "soft" states. Logging service check retries is mostly useful when attempting to debug Nagios or test out service event handlers.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_host_retries', 'This variable determines whether or not host check retries are logged. Logging host check retries is mostly useful when attempting to debug Nagios or test out host event handlers.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_event_handlers', 'This variable determines whether or not service and host event handlers are logged. Event handlers are optional commands that can be run whenever a service or hosts changes state. Logging event handlers is most useful when debugging Nagios or first trying out your event handler scripts.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_initial_states', 'This variable determines whether or not Nagios will force all initial host and service states to be logged, even if they result in an OK state. Initial service and host states are normally only logged when there is a problem on the first check. Enabling this option is useful if you are using an application that scans the log file to determine long-term state statistics for services and hosts.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_external_commands', 'This variable determines whether or not Nagios will log external commands that it receives from the external command file. Note: This option does not control whether or not passive service checks (which are a type of external command) get logged. To enable or disable logging of passive checks, use the log_passive_service_checks option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_passive_service_checks', 'This variable determines whether or not Nagios will log passive service checks that it receives from the external command file. If you are setting up a distributed monitoring environment or plan on handling a large number of passive checks on a regular basis, you may wish to disable this option so your log file doesn''t get too large.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'global_host_event_handler', 'This option allows you to specify a host event handler command that is to be run for every host state change. The global event handler is executed immediately prior to the event handler that you have optionally specified in each host definition. The command argument is the short name of a command that you define in your object configuration file. The maximum amount of time that this command can run is controlled by the event_handler_timeout option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'global_service_event_handler', 'This option allows you to specify a service event handler command that is to be run for every service state change. The global event handler is executed immediately prior to the event handler that you have optionally specified in each service definition. The command argument is the short name of a command that you define in your object configuration file. The maximum amount of time that this command can run is controlled by the event_handler_timeout option');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'sleep_time', 'This is the number of seconds that Nagios will sleep before checking to see if the next service check in the scheduling queue should be executed. Note that Nagios will only sleep after it "catches up" with queued service checks that have fallen behind.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'inter_check_delay_method', 'This option allows you to control how service checks are initially "spread out" in the event queue. Using a "smart" delay calculation (the default) will cause Nagios to calculate an average check interval and spread initial checks of all services out over that interval, thereby helping to eliminate CPU load spikes. Using no delay is generally not recommended unless you are testing the service check parallelization functionality. Using no delay will cause all service checks to be scheduled for execution at the same time. This means that you will generally have large CPU spikes when the services are all executed in parallel. Values are as follows:<br />\r\n* n = Don''t use any delay - schedule all service checks to run immediately (i.e. at the same time!)<br />\r\n* d = Use a "dumb" delay of 1 second between service checks<br />\r\n* s = Use a "smart" delay calculation to spread service checks out evenly (default)<br />* x.xx = Use a user-supplied inter-check delay of x.xx seconds');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'max_concurrent_checks', 'This option allows you to specify the maximum number of service checks that can be run in parallel at any given time. Specifying a value of 1 for this variable essentially prevents any service checks from being parallelized. Specifying a value of 0 (the default) does not place any restrictions on the number of concurrent checks. You''ll have to modify this value based on the system resources you have available on the machine that runs Nagios, as it directly affects the maximum load that will be imposed on the system (processor utilization, memory, etc.).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_reaper_frequency', 'This option allows you to control the frequency in seconds of service "reaper" events. "Reaper" events process the results from parallelized service checks that have finished executing. These events consitute the core of the monitoring logic in Nagios.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'interval_length', 'This is the number of seconds per "unit interval" used for timing in the scheduling queue, re-notifications, etc. "Units intervals" are used in the host configuration file to determine how often to run a service check, how often of re-notify a contact, etc.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_interleave_factor', 'This variable determines how service checks are interleaved. Interleaving allows for a more even distribution of service checks, reduced load on remote hosts, and faster overall detection of host problems. With the introduction of service check parallelization, remote hosts could get bombarded with checks if interleaving was not implemented. This could cause the service checks to fail or return incorrect results if the remote host was overloaded with processing other service check requests. Setting this value to 1 is equivalent to not interleaving the service checks (this is how versions of Nagios previous to 0.0.5 worked). Set this value to s (smart) for automatic calculation of the interleave factor unless you have a specific reason to change it. The best way to understand how interleaving works is to watch the status CGI (detailed view) when Nagios is just starting. You should see that the service check results are spread out as they begin to appear.<br />\r\n* x = A number greater than or equal to 1 that specifies the interleave factor to use. An interleave factor of 1 is equivalent to not interleaving the service checks.<br />\r\n* s = Use a "smart" interleave factor calculation (default)<br />');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'use_agressive_host_checking', 'Nagios tries to be smart about how and when it checks the status of hosts. In general, disabling this option will allow Nagios to make some smarter decisions and check hosts a bit faster. Enabling this option will increase the amount of time required to check hosts, but may improve reliability a bit. Unless you have problems with Nagios not recognizing that a host recovered, I would suggest not enabling this option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'enable_flap_detection', 'This option determines whether or not Nagios will try and detect hosts and services that are "flapping". Flapping occurs when a host or service changes between states too frequently, resulting in a barrage of notifications being sent out. When Nagios detects that a host or service is flapping, it will temporarily suppress notifications for that host/service until it stops flapping. Flap detection is very experimental at this point, so use this feature with caution! Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you''ll have to use the appropriate external command or change it via the web interface.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'low_service_flap_threshold', 'This option is used to set the low threshold for detection of service flapping.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'high_service_flap_threshold', 'This option is used to set the low threshold for detection of service flapping.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'low_host_flap_threshold', 'This option is used to set the low threshold for detection of host flapping.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'high_host_flap_threshold', 'This option is used to set the low threshold for detection of host flapping.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'soft_state_dependencies', 'This option determines whether or not Nagios will use soft service state information when checking service dependencies. Normally Nagios will only use the latest hard service state when checking dependencies. If you want it to use the latest state (regardless of whether its a soft or hard state type), enable this option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_check_timeout', 'This is the maximum number of seconds that Nagios will allow service checks to run. If checks exceed this limit, they are killed and a CRITICAL state is returned. A timeout error will also be logged.\r\n\r\nThere is often widespread confusion as to what this option really does. It is meant to be used as a last ditch mechanism to kill off plugins which are misbehaving and not exiting in a timely manner. It should be set to something high (like 60 seconds or more), so that each service check normally finishes executing within this time limit. If a service check runs longer than this limit, Nagios will kill it off thinking it is a runaway processes. ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'host_check_timeout', 'This is the maximum number of seconds that Nagios will allow host checks to run. If checks exceed this limit, they are killed and a CRITICAL state is returned and the host will be assumed to be DOWN. A timeout error will also be logged.\r\n\r\nThere is often widespread confusion as to what this option really does. It is meant to be used as a last ditch mechanism to kill off plugins which are misbehaving and not exiting in a timely manner. It should be set to something high (like 60 seconds or more), so that each host check normally finishes executing within this time limit. If a host check runs longer than this limit, Nagios will kill it off thinking it is a runaway processes. ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'event_handler_timeout', 'This is the maximum number of seconds that Nagios will allow event handlers to be run. If an event handler exceeds this time limit it will be killed and a warning will be logged.\r\n\r\nThere is often widespread confusion as to what this option really does. It is meant to be used as a last ditch mechanism to kill off commands which are misbehaving and not exiting in a timely manner. It should be set to something high (like 60 seconds or more), so that each event handler command normally finishes executing within this time limit. If an event handler runs longer than this limit, Nagios will kill it off thinking it is a runaway processes. ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'notification_timeout', 'This is the maximum number of seconds that Nagios will allow notification commands to be run. If a notification command exceeds this time limit it will be killed and a warning will be logged.\r\n\r\nThere is often widespread confusion as to what this option really does. It is meant to be used as a last ditch mechanism to kill off commands which are misbehaving and not exiting in a timely manner. It should be set to something high (like 60 seconds or more), so that each notification command finishes executing within this time limit. If a notification command runs longer than this limit, Nagios will kill it off thinking it is a runaway processes. ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'ocsp_timeout', 'This is the maximum number of seconds that Nagios will allow an obsessive compulsive service processor command to be run. If a command exceeds this time limit it will be killed and a warning will be logged.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'perfdata_timeout', 'This is the maximum number of seconds that Nagios will allow a host performance data processor command or service performance data processor command to be run. If a command exceeds this time limit it will be killed and a warning will be logged.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'obsess_over_services', 'This value determines whether or not Nagios will "obsess" over service checks results and run the obsessive compulsive service processor command you define. I know - funny name, but it was all I could think of. This option is useful for performing distributed monitoring. If you''re not doing distributed monitoring, don''t enable this option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'ocsp_command', 'This option allows you to specify a command to be run after every service check, which can be useful in distributed monitoring. This command is executed after any event handler or notification commands. The command argument is the short name of a command definition that you define in your host configuration file. The maximum amount of time that this command can run is controlled by the ocsp_timeout option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'process_performance_data', 'This value determines whether or not Nagios will process host and service check performance data.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'host_perfdata_command', 'This is the command that will be run to process host performance data.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_perfdata_command', 'This is the command that will be run to process service performance data.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'check_for_orphaned_services', 'This option allows you to enable or disable checks for orphaned service checks. Orphaned service checks are checks which ahve been executed and have been removed from the event queue, but have not had any results reported in a long time. Since no results have come back in for the service, it is not rescheduled in the event queue. This can cause service checks to stop being executed. Normally it is very rare for this to happen - it might happen if an external user or process killed off the process that was being used to execute a service check. If this option is enabled and Nagios finds that results for a particular service check have not come back, it will log an error message and reschedule the service check. If you start seeing service checks that never seem to get rescheduled, enable this option and see if you notice any log messages about orphaned services.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'check_service_freshness', 'This option determines whether or not Nagios will periodically check the "freshness" of service checks. Enabling this option is useful for helping to ensure that passive service checks are received in a timely manner.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'freshness_check_interval', 'This setting determines how often (in seconds) Nagios will periodically check the "freshness" of service check results. If you have disabled service freshness checking (with the check_service_freshness option), this option has no effect.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'date_format', 'This option allows you to specify what kind of date/time format Nagios should use in the web interface and date/time macros.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'illegal_object_name_chars', 'This option allows you to specify illegal characters that cannot be used in host names, service descriptions, or names of other object types.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'illegal_macro_output_chars', 'This option allows you to specify illegal characters that should be stripped from macros before being used in notifications, event handlers, and other commands. This DOES NOT affect macros used in service or host check commands. You can choose to not strip out the characters shown in the example above, but I recommend you do not do this. Some of these characters are interpreted by the shell (i.e. the backtick) and can lead to security problems. The following macros are stripped of the characters you specify: $OUTPUT$, $PERFDATA$ ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'admin_email', 'This is the email address for the administrator of the local machine (i.e. the one that Nagios is running on). This value can be used in notification commands by using the $ADMINEMAIL$ macro.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'admin_pager', 'This is the pager number (or pager email gateway) for the administrator of the local machine (i.e. the one that Nagios is running on). The pager number/address can be used in notification commands by using the $ADMINPAGER$ macro.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'use_retained_scheduling_info', 'This setting determines whether or not Nagios will retain scheduling info (next check times) for hosts and services when it restarts. If you are adding a large number (or percentage) of hosts and services, I would recommend disabling this option when you first restart Nagios, as it can adversely skew the spread of initial checks.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'accept_passive_host_checks', 'This option determines whether or not Nagios will accept passive host checks when it initially (re)starts. If this option is disabled, Nagios will not accept any passive host checks. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you''ll have to use the appropriate external command or change it via the web interface.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'execute_host_checks', 'This option determines whether or not Nagios will execute on-demand and regularly scheduled host checks when it initially (re)starts. If this option is disabled, Nagios will not actively execute any host checks, although it can still accept passive host checks unless you''ve disabled them). This option is most often used when configuring backup monitoring servers, as described in the documentation on redundancy, or when setting up a distributed monitoring environment. Note: If you have state retention enabled, Nagios will ignore this setting when it (re)starts and use the last known setting for this option (as stored in the state retention file), unless you disable the use_retained_program_state option. If you want to change this option when state retention is active (and the use_retained_program_state is enabled), you''ll have to use the appropriate external command or change it via the web interface.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'object_cache_file', 'This directive is used to specify a file in which a cached copy of object definitions should be stored. The cache file is (re)created every time Nagios is (re)started and is used by the CGIs. It is intended to speed up config file caching in the CGIs and allow you to edit the source object config files while Nagios is running without affecting the output displayed in the CGIs.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'precached_object_file', 'This directive is used to specify a file in which
	a pre-processed, pre-cached copy of object definitions should be stored.
	This file can be used to drastically improve startup times in large/complex
	Nagios installations.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'retained_host_attribute_mask', 'These options determine which host 
	 attributes are NOT retained across program restarts. The values for
	these options are a bitwise AND of values specified by the "MODATTR_"
	definitions in the include/common.h source code file. By default, all host
	attributes are retained.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'retained_service_attribute_mask', 'These options determine which service 
	 attributes are NOT retained across program restarts. The values for
	these options are a bitwise AND of values specified by the "MODATTR_"
	definitions in the include/common.h source code file. By default, all service
	attributes are retained.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'retained_process_host_attribute_mask', 'These options determine which
	process attributes are NOT retained across program restarts. There are two
	masks because there are often separate host and service process attributes
	that can be changed. For example, host checks can be disabled at the program
	level, while service checks are still enabled. The values for these options
	are a bitwise AND of values specified by the "MODATTR_" definitions in the
	include/common.h source code file. By default, all process attributes are
	retained. ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'retained_process_service_attribute_mask', 'These options determine which
	process attributes are NOT retained across program restarts. There are two
	masks because there are often separate host and service process attributes
	that can be changed. For example, host checks can be disabled at the program
	level, while service checks are still enabled. The values for these options
	are a bitwise AND of values specified by the "MODATTR_" definitions in the
	include/common.h source code file. By default, all process attributes are
	retained. ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'retained_contact_host_attribute_mask', 'These options determine which
	contact attributes are NOT retained across program restarts. There are two
	masks because there are often separate host and service contact attributes
	that can be changed. The values for these options are a bitwise AND of
	values specified by the "MODATTR_" definitions in the include/common.h
	source code file. By default, all process attributes are retained. ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'retained_contact_service_attribute_mask', 'These options determine which
	contact attributes are NOT retained across program restarts. There are two
	masks because there are often separate host and service contact attributes
	that can be changed. The values for these options are a bitwise AND of
	values specified by the "MODATTR_" definitions in the include/common.h
	source code file. By default, all process attributes are retained. ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'check_result_reaper_frequency', 'This option allows you to control the
	frequency in seconds of check result "reaper" events. "Reaper" events
	process the results from host and service checks that have finished
	executing. These events consitute the core of the monitoring logic in
	Nagios. ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'max_check_result_reaper_time', 'This option allows you to control the
	maximum amount of time in seconds that host and service check result
	"reaper" events are allowed to run. "Reaper" events process the results from
	host and service checks that have finished executing. If there are a lot of
	results to process, reaper events may take a long time to finish, which
	might delay timely execution of new host and service checks. This variable
	allows you to limit the amount of time that an individual reaper event will
	run before it hands control back over to Nagios for other portions of the
	monitoring logic. ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'check_result_path', 'This options determines which directory Nagios will
	use to temporarily store host and service check results before they are
	processed. This directory should not be used to store any other files, as
	Nagios will periodically clean this directory of old file (see the
		max_check_result_file_age option for more information).
	
	Note: Make sure that only a single instance of Nagios has access to the
	check result path. If multiple instances of Nagios have their check result
	path set to the same directory, you will run into problems with check
	results being processed (incorrectly) by the wrong instance of Nagios! ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'max_check_result_file_age', 'This options determines the maximum age in
	seconds that Nagios will consider check result files found in the
	check_result_path directory to be valid. Check result files that are older
	that this threshold will be deleted by Nagios and the check results they
	contain will not be processed. By using a value of zero (0) with this
	option, Nagios will process all check result files - even if they\'re older
	than your hardware :-). ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'translate_passive_host_checks', 'This option determines whether or not
	Nagios will translate DOWN/UNREACHABLE passive host check results to their
	"correct" state from the viewpoint of the local Nagios instance. This can be
	very useful in distributed and failover monitoring installations.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'passive_host_checks_are_soft', 'This option determines whether or not
	Nagios will treat passive host checks as HARD states or SOFT states. By
	default, a passive host check result will put a host into a HARD state type.
	You can change this behavior by enabling this option. ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'enable_predictive_host_dependency_checks', 'This option determines whether
	or not Nagios will execute predictive checks of hosts that are being
	depended upon (as defined in host dependencies) for a particular host when
	it changes state. Predictive checks help ensure that the dependency logic is
	as accurate as possible.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'enable_predictive_service_dependency_checks', 'This option determines
	whether or not Nagios will execute predictive checks of services that are
	being depended upon (as defined in service dependencies) for a particular
	service when it changes state. Predictive checks help ensure that the
	dependency logic is as accurate as possible.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'cached_host_check_horizon', 'This option determines the maximum amount of
	time (in seconds) that the state of a previous host check is considered
	current. Cached host states (from host checks that were performed more
		recently than the time specified by this value) can improve host check
	performance immensely. Too high of a value for this option may result in
	(temporarily) inaccurate host states, while a low value may result in a
	performance hit for host checks. Use a value of 0 if you want to disable
	host check caching.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'cached_service_check_horizon', 'This option determines the maximum amount
	of time (in seconds) that the state of a previous service check is
	considered current. Cached service states (from service checks that were
		performed more recently than the time specified by this value) can
	improve service check performance when a lot of service dependencies are
	used. Too high of a value for this option may result in inaccuracies in the
	service dependency logic. Use a value of 0 if you want to disable service
	check caching.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'use_large_installation_tweaks', 'This option determines whether or not the
	Nagios daemon will take several shortcuts to improve performance. These
	shortcuts result in the loss of a few features, but larger installations
	will likely see a lot of benefit from doing so.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'free_child_process_memory', 'This option determines whether or not Nagios
	will free memory in child processes when they are fork()ed off from the main
	process. By default, Nagios frees memory. However, if the
	use_large_installation_tweaks option is enabled, it will not. By defining
	this option in your configuration file, you are able to override things to
	get the behavior you want.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'child_processes_fork_twice', 'This option determines whether or not Nagios
	will fork() child processes twice when it executes host and service checks.
	By default, Nagios fork()s twice. However, if the
	use_large_installation_tweaks option is enabled, it will only fork() once.
	By defining this option in your configuration file, you are able to override
	things to get the behavior you want. ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'enable_environment_macros', 'This option determines whether or not the
	Nagios daemon will make all standard macros available as environment
	variables to your check, notification, event hander, etc. commands. In large
	Nagios installations this can be problematic because it takes additional
	memory and (more importantly) CPU to compute the values of all macros and
	make them available to the environment. ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'additional_freshness_latency', 'This option determines the number of
	seconds Nagios will add to any host or services freshness threshold it
	automatically calculates (e.g. those not specified explicity by the user).');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'enable_embedded_perl', 'This setting determines whether or not the embedded
	Perl interpreter is enabled on a program-wide basis. Nagios must be compiled
	with support for embedded Perl for this option to have an effect.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'use_embedded_perl_implicitly', 'This setting determines whether or not the
	embedded Perl interpreter should be used for Perl plugins/scripts that do
	not explicitly enable/disable it. Nagios must be compiled with support for
	embedded Perl for this option to have an effect.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'use_timezone', 'This option allows you to override the default timezone
	that this instance of Nagios runs in. Useful if you have multiple instances
	of Nagios that need to run from the same server, but have different local
	times associated with them. If not specified, Nagios will use the system
	configured timezone. ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'debug_file', 'This option determines where Nagios should write debugging
	information. What (if any) information is written is determined by the
	debug_level and debug_verbosity options.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'debug_level', 'This option determines what type of information Nagios
	should write to the debug_file.');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'debug_verbosity', 'This option determines how much debugging information
	Nagios should write to the debug_file. ');
REPLACE INTO `label`(section, name, label) VALUES('nagios_main_desc',
	'max_debug_file_size', 'This option determines the maximum size (in bytes)
	of the debug file. If the file grows larger than this size, it will be
	renamed with a .old extension. If a file already exists with a .old
	extension it will automatically be deleted. This helps ensure your disk
	space usage doesn\'t get out of control when debugging Nagios. ');













REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_inter_check_delay_method', 'This option allows you to control how service checks are initially "spread out" in the event queue. Using a "smart" delay calculation (the default) will cause Nagios to calculate an average check interval and spread initial checks of all services out over that interval, thereby helping to eliminate CPU load spikes. Using no delay is generally not recommended unless you are testing the service check parallelization functionality. Using no delay will cause all service checks to be scheduled for execution at the same time. This means that you will generally have large CPU spikes when the services are all executed in parallel. Values are as follows:\r\n\r\n    * n = Don''t use any delay - schedule all service checks to run immediately (i.e. at the same time!)<br />\r\n- d = Use a "dumb" delay of 1 second between service checks<br />\r\n- s = Use a "smart" delay calculation to spread service checks out evenly (default)<br />\r\n- x.xx = Use a user-supplied inter-check delay of x.xx seconds<br />');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'max_service_check_spread', 'This option determines the maximum number of minutes from when Nagios starts that all services (that are scheduled to be regularly checked) are checked. This option will automatically adjust the service inter-check delay (if necessary) to ensure that the initial checks of all services occur within the timeframe you specify. In general, this option will not have an affect on service check scheduling if scheduling information is being retained using the use_retained_scheduling_info option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'host_inter_check_delay_method', 'This option allows you to control how host checks that are scheduled to be checked on a regular basis are initially "spread out" in the event queue. Using a "smart" delay calculation (the default) will cause Nagios to calculate an average check interval and spread initial checks of all hosts out over that interval, thereby helping to eliminate CPU load spikes. Using no delay is generally not recommended. Using no delay will cause all host checks to be scheduled for execution at the same time. Values are as follows:<br />\r\n* n = Don''t use any delay - schedule all host checks to run immediately (i.e. at the same time!)<br />\r\n* d = Use a "dumb" delay of 1 second between host checks<br />\r\n* s = Use a "smart" delay calculation to spread host checks out evenly (default)<br />\r\n* x.xx = Use a user-supplied inter-check delay of x.xx seconds');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'max_host_check_spread', 'This option determines the maximum number of minutes from when Nagios starts that all hosts (that are scheduled to be regularly checked) are checked. This option will automatically adjust the host inter-check delay (if necessary) to ensure that the initial checks of all hosts occur within the timeframe you specify. In general, this option will not have an affect on host check scheduling if scheduling information is being retained using the use_retained_scheduling_info option. Default value is 30 (minutes).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'auto_reschedule_checks', 'This option determines whether or not Nagios will attempt to automatically reschedule active host and service checks to "smooth" them out over time. This can help to balance the load on the monitoring server, as it will attempt to keep the time between consecutive checks consistent, at the expense of executing checks on a more rigid schedule.<br />\r\n<b>WARNING:</b> THIS IS AN EXPERIMENTAL FEATURE AND MAY BE REMOVED IN FUTURE VERSIONS. ENABLING THIS OPTION CAN DEGRADE PERFORMANCE - RATHER THAN INCREASE IT - IF USED IMPROPERLY! ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'auto_rescheduling_interval', 'This option determines how often (in seconds) Nagios will attempt to automatically reschedule checks. This option only has an effect if the auto_reschedule_checks option is enabled. Default is 30 seconds.<br />\r\n<b>WARNING:</b> THIS IS AN EXPERIMENTAL FEATURE AND MAY BE REMOVED IN FUTURE VERSIONS. ENABLING THE AUTO-RESCHEDULING OPTION CAN DEGRADE PERFORMANCE - RATHER THAN INCREASE IT - IF USED IMPROPERLY! ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'auto_rescheduling_window', 'This option determines the "window" of time (in seconds) that Nagios will look at when automatically rescheduling checks. Only host and service checks that occur in the next X seconds (determined by this variable) will be rescheduled. This option only has an effect if the auto_reschedule_checks option is enabled. Default is 180 seconds (3 minutes).<br />\r\n<b>WARNING:</b> THIS IS AN EXPERIMENTAL FEATURE AND MAY BE REMOVED IN FUTURE VERSIONS. ENABLING THE AUTO-RESCHEDULING OPTION CAN DEGRADE PERFORMANCE - RATHER THAN INCREASE IT - IF USED IMPROPERLY! ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'ochp_timeout', 'This is the maximum number of seconds that Nagios will allow an obsessive compulsive host processor command to be run. If a command exceeds this time limit it will be killed and a warning will be logged.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'obsess_over_hosts', 'This value determines whether or not Nagios will "obsess" over host checks results and run the obsessive compulsive host processor command you define. I know - funny name, but it was all I could think of. This option is useful for performing distributed monitoring. If you''re not doing distributed monitoring, don''t enable this option.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'ochp_command', 'This option allows you to specify a command to be run after every host check, which can be useful in distributed monitoring. This command is executed after any event handler or notification commands. The command argument is the short name of a command definition that you define in your host configuration file. The maximum amount of time that this command can run is controlled by the ochp_timeout option. This command is only executed if the obsess_over_hosts option is enabled globally and if the obsess_over_host directive in the host definition is enabled.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'check_host_freshness', 'This option determines whether or not Nagios will periodically check the "freshness" of host checks. Enabling this option is useful for helping to ensure that passive host checks are received in a timely manner.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'host_freshness_check_interval', 'This setting determines how often (in seconds) Nagios will periodically check the "freshness" of host check results. If you have disabled host freshness checking (with the check_host_freshness option), this option has no effect.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_freshness_check_interval', 'This setting determines how often (in seconds) Nagios will periodically check the "freshness" of service check results. If you have disabled service freshness checking (with the check_service_freshness option), this option has no effect.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'use_regexp_matching', 'This option determines whether or not various directives in your object definitions will be processed as regular expressions.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'use_true_regexp_matching', 'If you''ve enabled regular expression matching of various object directives using the use_regexp_matching option, this option will determine when object directives are treated as regular expressions. If this option is disabled (the default), directives will only be treated as regular expressions if the contain a * or ? wildcard character. If this option is enabled, all appropriate directives will be treated as regular expression - be careful when enabling this!');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_passive_checks', 'This variable determines whether or not Nagios will log passive host and service checks that it receives from the external command file. If you are setting up a distributed monitoring environment or plan on handling a large number of passive checks on a regular basis, you may wish to disable this option so your log file doesn''t get too large.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'daemon_dumps_core', 'This option determines whether or not Nagios is allowed to create a core dump when it runs as a daemon.  Note that it is generally considered bad form to allow this, but it may be useful for debugging purposes.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'host_perfdata_file', 'This option allows you to specify a file to which host performance data will be written after every host check. Data will be written to the performance file as specified by the host_perfdata_file_template option. Performance data is only written to this file if the process_performance_data option is enabled globally and if the process_perf_data directive in the host definition is enabled.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_perfdata_file', 'This option allows you to specify a file to which service performance data will be written after every service check. Data will be written to the performance file as specified by the service_perfdata_file_template option. Performance data is only written to this file if the process_performance_data option is enabled globally and if the process_perf_data directive in the service definition is enabled.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'host_perfdata_file_template', 'This option determines what (and how) data is written to the host performance data file. The template may contain macros, special characters (\\t for tab, \\r for carriage return, \\n for newline) and plain text. A newline is automatically added after each write to the performance data file.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_perfdata_file_template', 'This option determines what (and how) data is written to the service performance data file. The template may contain macros, special characters (\\t for tab, \\r for carriage return, \\n for newline) and plain text. A newline is automatically added after each write to the performance data file.\r\n\r\n');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'host_perfdata_file_mode', 'This option determines whether the host performance data file is opened in write or append mode. Unless the file is a named pipe, you will probably want to use the default mode of append.\r\n\r\n    * a = Open file in append mode (default)\r\n    * w = Open file in write mode ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_perfdata_file_mode', 'This option determines whether the service performance data file is opened in write or append mode. Unless the file is a named pipe, you will probably want to use the default mode of append.\r\n\r\n    * a = Open file in append mode (default)\r\n    * w = Open file in write mode ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'host_perfdata_file_processing_interval', 'This option allows you to specify the interval (in seconds) at which the host performance data file is processed using the host performance data file processing command. A value of 0 indicates that the performance data file should not be processed at regular intervals.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_perfdata_file_processing_interval', 'This option allows you to specify the interval (in seconds) at which the service performance data file is processed using the service performance data file processing command. A value of 0 indicates that the performance data file should not be processed at regular intervals.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'host_perfdata_file_processing_command', 'This option allows you to specify the command that should be executed to process the host performance data file. The command argument is the short name of a command definition that you define in your object configuration file. The interval at which this command is executed is determined by the host_perfdata_file_processing_interval directive.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_perfdata_file_processing_command', 'This option allows you to specify the command that should be executed to process the service performance data file. The command argument is the short name of a command definition that you define in your object configuration file. The interval at which this command is executed is determined by the service_perfdata_file_processing_interval directive.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'host_perfdata_file', 'This directive is used to specify the file where host performance data should be written. An example entry in your main config file might look like this: xpdfile_host_perfdata_file=/usr/local/nagios/var/hostperf.log ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'host_perfdata_template', 'This directive determines how the host performance data is written to the file. The example template definition show below will cause the performance data to be written to the file in tab-delimited format, with one entry per line (\\t, \\r and \\n are interpreted as tab, carriage return, and newline characters respectively).<br />\r\nxpdfile_host_perfdata_template=$TIMET$\\t$HOSTNAME$\\t$OUTPUT$\\t$PERFDATA$');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_perfdata_file', 'This directive is used to specify the file where service performance data should be written. An example entry in your main config file might look like this: service_perfdata_file=/usr/local/nagios/var/serviceperf.log ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'service_perfdata_template', 'This directive determines how the service performance data is written to the file. The example template definition show below will cause the performance data to be written to the file in tab-delimited format, with one entry per line (\\t, \\r and \\n are interpreted as tab, carriage return, and newline characters respectively).<br />\r\nxpdfile_service_perfdata_template=$TIMET$\\t$HOSTNAME$\\t$SERVICEDESC$\\t$OUTPUT$\\t$PERFDATA$ ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'event_broker_options', 'Controls what (if any) data gets sent to the event broker.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'check_for_updates', 'This option determines whether Nagios will automatically check to see if new updates (releases) are available. It is recommend that you enable this option to ensure that you stay on top of the latest critical patches to Nagios. Nagios is critical to you - make sure you keep it in good shape. Nagios will check once a day for new updates. Data collected by Nagios Enterprises from the update check is processed in accordance with our privacy policy - see <a href="http://api.nagios.org">http://api.nagios.org</a> for details.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'check_for_orphaned_hosts', 'This option allows you to enable or disable checks for orphaned hoste checks. Orphaned host checks are checks which have been executed and have been removed from the event queue, but have not had any results reported in a long time. Since no results have come back in for the host, it is not rescheduled in the event queue. This can cause host checks to stop being executed. Normally it is very rare for this to happen - it might happen if an external user or process killed off the process that was being used to execute a host check. If this option is enabled and Nagios finds that results for a particular host check have not come back, it will log an error message and reschedule the host check. If you start seeing host checks that never seem to get rescheduled, enable this option and see if you notice any log messages about orphaned hosts.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'bare_update_check', 'This option deterines what data Nagios will send to api.nagios.org when it checks for updates. By default, Nagios will send information on the current version of Nagios you have installed, as well as an indicator as to whether this was a new installation or not. Nagios Enterprises uses this data to determine the number of users running specific version of Nagios. Enable this option if you do not wish for this information to be sent.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_servicegroups_desc', 'alias', 'This directive is used to define is a longer name or description used to identify the service group. It is provided in order to allow you to more easily identify a particular service group.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_servicegroups_desc', 'servicegroup_name', 'This directive is used to define a short name used to identify the service group.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'service_description', 'This directive is used to define the description of the service, which may contain spaces, dashes, and colons (semicolons, apostrophes, and quotation marks should be avoided). No two services associated with the same host can have the same description. Services are uniquely identified with their host_name and service_description directives.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'is_volatile', 'This directive is used to denote whether the service is "volatile". Services are normally not volatile.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'max_check_attempts', 'This directive is used to define the number of times that Nagios will retry the service check command if it returns any state other than an OK state. Setting this value to 1 will cause Nagios to generate an alert without retrying the service check again.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'normal_check_interval', 'This directive is used to define the number of "time units" to wait before scheduling the next "regular" check of the service. "Regular" checks are those that occur when the service is in an OK state or when the service is in a non-OK state, but has already been rechecked max_attempts number of times. Unless you''ve changed the interval_length directive from the default value of 60, this number will mean minutes. More information on this value can be found in the check scheduling documentation.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'retry_check_interval', 'This directive is used to define the number of "time units" to wait before scheduling a re-check of the service. Services are rescheduled at the retry interval when the have changed to a non-OK state. Once the service has been retried max_attempts times without a change in its status, it will revert to being scheduled at its "normal" rate as defined by the check_interval value. Unless you''ve changed the interval_length directive from the default value of 60, this number will mean minutes.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'active_checks_enabled', 'This directive is used to determine whether or not active checks of this service are enabled. Values: 0 = disable active service checks, 1 = enable active service checks.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'passive_checks_enabled', 'This directive is used to determine whether or not passive checks of this service are enabled.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'check_period', 'This directive is used to specify the short name of the time period during which active checks of this service can be made.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'parallelize_check', 'This directive is used to determine whether or not the service check can be parallelized. By default, all service checks are parallelized. Disabling parallel checks of services can result in serious performance problems. ');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'check_freshness', 'This directive is used to determine whether or not freshness checks are enabled for this service.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'freshness_threshold', 'This directive is used to specify the freshness threshold (in seconds) for this service. If you set this directive to a value of 0, Nagios will determine a freshness threshold to use automatically.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'event_handler_enabled', 'This directive is used to determine whether or not the event handler for this service is enabled.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'low_flap_threshold', 'This directive is used to specify the low state change threshold used in flap detection for this service. If you set this directive to a value of 0, the program-wide value specified by the low_service_flap_threshold directive will be used.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'high_flap_threshold', 'This directive is used to specify the high state change threshold used in flap detection for this service. If you set this directive to a value of 0, the program-wide value specified by the high_service_flap_threshold directive will be used.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'flap_detection_enabled', 'This directive is used to determine whether or not flap detection is enabled for this service.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'process_perf_data', 'This directive is used to determine whether or not the processing of performance data is enabled for this service.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'retain_status_information', 'This directive is used to determine whether or not status-related information about the service is retained across program restarts. This is only useful if you have enabled state retention using the retain_state_information directive.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'retain_nonstatus_information', 'This directive is used to determine whether or not non-status information about the service is retained across program restarts. This is only useful if you have enabled state retention using the retain_state_information directive.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'notification_interval', 'This directive is used to define the number of "time units" to wait before re-notifying a contact that this service is still in a non-OK state. Unless you''ve changed the interval_length directive from the default value of 60, this number will mean minutes. If you set this value to 0, Nagios will not re-notify contacts about problems for this service - only one problem notification will be sent out, unless there has been a state change.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'notification_period', 'This directive is used to specify the short name of the time period during which notifications of events for this service can be sent out to contacts. No service notifications will be sent out during times which is not covered by the time period.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'notification_options', 'This directive is used to determine when notifications for the service should be sent out.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'notifications_enabled', 'This directive is used to determine whether or not notifications for this service are enabled.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'contact_groups', 'This is a list of the short names of the contact groups that should be notified whenever there are problems (or recoveries) with this service. Multiple contact groups should be separated by commas.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'stalking_options', 'This directive determines which service states "stalking" is enabled for.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'check_command', 'The full path and arguments to the command to run for this service''s checks.  If you leave this as empty, you will be able to select a pre-defined command with arguments later.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'user_check_command', 'Insert the full command line for your User Defined check command.  Used only if selected User Defined in check command.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_desc', 'host_name', 'This directive is used to specify the short name of the service that is linked to this host or hostgroup.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_extended_info_desc', 'notes', 'This directive is used to define an optional string of notes pertaining to the service. If you specify a note here, you will see the it in the extended information CGI (when you are viewing information about the specified service).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_extended_info_desc', 'notes_url', 'This directive is used to define an optional URL that can be used to provide more information about the service. If you specify an URL, you will see a link that says "Extra Service Notes" in the extended information CGI (when you are viewing information about the specified service). Any valid URL can be used. If you plan on using relative paths, the base path will the the same as what is used to access the CGIs (i.e. /cgi-bin/nagios/). This can be very useful if you want to make detailed information on the service, emergency contact methods, etc. available to other support staff.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_extended_info_desc', 'action_url', '	This directive is used to define an optional URL that can be used to provide more actions to be performed on the service. If you specify an URL, you will see a link that says "Extra Service Actions" in the extended information CGI (when you are viewing information about the specified service). Any valid URL can be used. If you plan on using relative paths, the base path will the the same as what is used to access the CGIs (i.e. /cgi-bin/nagios/).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_extended_info_desc', 'icon_image', 'This variable is used to define the name of a GIF, PNG, or JPG image that should be associated with this host. This image will be displayed in the status and extended information CGIs. The image will look best if it is 40x40 pixels in size. Images for hosts are assumed to be in the logos/ subdirectory in your HTML images directory (i.e. /usr/local/nagios/share/images/logos).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_services_extended_info_desc', 'icon_image_alt', 'This variable is used to define an optional string that is used in the ALT tag of the image specified by the <icon_image> argument. The ALT tag is used in the status, extended information and statusmap CGIs.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_timeperiods_desc', 'timeperiod_name', 'This directives is the short name used to identify the time period.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_timeperiods_desc', 'alias', 'This directive is a longer name or description used to identify the time period.\r\n');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_timeperiods_desc', 'days', 'The sunday through saturday directives are comma-delimited lists of time ranges that are "valid" times for a particular day of the week. Notice that there are seven different days for which you can define time ranges (Sunday through Saturday). Each time range is in the form of HH:MM-HH:MM, where hours are specified on a 24 hour clock. For example, 00:15-24:00 means 12:15am in the morning for this day until 12:20am midnight (a 23 hour, 45 minute total time range). If you wish to exclude an entire day from the timeperiod, simply leave it blank.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_timeperiods_desc', 'timeperiod_weekday_exception', 'You can specify a weekday by using \"sunday\" through \"saturday\".  You can also provide an exception which is explained in detail at <a href=\"http://nagios.sourceforge.net/docs/3_0/timeperiods.html\">Nagios\' Timeperiod Documentation</a>.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_timeperiods_desc', 'timeperiod_value', 'Each time range is in the form of HH:MM-HH:MM, where hours are specified on a 24 hour clock. For example, 00:15-24:00 means 12:15am in the morning for this day until 12:00am midnight (a 23 hour, 45 minute total time range). If you wish to exclude an entire day from the timeperiod, simply do not include it in the timeperiod definition. Multiple ranges can be provided as long as they are comma-delimited.  You can also provide a blank value to disable this weekday/exception.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_timeperiods_desc', 'exclusion', 'Specify the names of other timeperiod definitions whose time ranges should be excluded from this timeperiod.');
REPLACE INTO `label`(section, name, label)  VALUES('host_template_autodiscovery', 'autodiscovery_address_filter', 'Specify a valid PCRE Regex Pattern to match against a discovered device\'s address.');
REPLACE INTO `label`(section, name, label)  VALUES('host_template_autodiscovery', 'autodiscovery_hostname_filter', 'Specify a valid PCRE Regex Pattern to match against a discovered device\'s hostname.  If the hostname cannot be looked up, the device\'s address will be used instead.');
REPLACE INTO `label`(section, name, label)  VALUES('host_template_autodiscovery', 'autodiscovery_os_family_filter', 'Specify a valid PCRE Regex Pattern to match against a discovered device\'s family of Operating System.  If this is set, the autodiscovery system MUST get back a value from the device.');
REPLACE INTO `label`(section, name, label)  VALUES('host_template_autodiscovery', 'autodiscovery_os_generation_filter', 'Specify a valid PCRE Regex Pattern to match against a discovered device\'s generation of Operating System.  If this is set, the autodiscovery system MUST get back a value from the device.');
REPLACE INTO `label`(section, name, label)  VALUES('host_template_autodiscovery', 'autodiscovery_os_vendor_filter', 'Specify a valid PCRE Regex Pattern to match against a discovered device\'s Operating System Vendor.  If this is set, the autodiscovery system MUST get back a value from the device.');
REPLACE INTO `label`(section, name, label)  VALUES('host_template_autodiscovery', 'autodiscovery_service_filter_name', 'Specify a valid PCRE Regex Pattern to match against a discovered service\s name.  If this is set, the autodiscovery system MUST get back a value from the device.');
REPLACE INTO `label`(section, name, label)  VALUES('host_template_autodiscovery', 'autodiscovery_service_filter_product', 'Specify a valid PCRE Regex Pattern to match against a discovered service\s product information..  If this is set, the autodiscovery system MUST get back a value from the device.  A Regex Pattern can also be provided for the version.');
REPLACE INTO `label`(section, name, label)  VALUES('host_template_autodiscovery', 'autodiscovery_service_filter_extra_information', 'Specify a valid PCRE Regex Pattern to match against a discovered service\s extra information.  If this is set, the autodiscovery system MUST get back a value from the device.');

REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'authorized_for_read_only', 'A comma-delimited list of usernames that have read-only rights in the CGIs. This will block any service or host commands normally shown on the extinfo CGI pages. It will also block comments from being shown to read-only users.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'color_transparency_index', 'These options set the r,g,b values of the background color used the statusmap CGI, so normal browsers that can''t show real png transparency set the desired color as a background color instead (to make it look pretty). Defaults to white: (R,G,B) = (255,255,255).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_cgi_desc', 'result_limit', 'The number of services being shown in Nagios at the same time.');

REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'log_current_states', ' This option determines whether or not Nagios will log host and service current states at the beginning of a newly created log file after log rotation occurs. In Nagios Core 3, current states were always logged after a log rotation. In Nagios Core 4, the default behavior is to log current states after log rotation, but it can be disabled by setting log_current_states=0. In a large installation, disabling the logging of current states after log rotation can save considerable amounts of disk space, especially if the logs are rotated frequently. This risk is that, if logs are aged off and deleted, you may not have sufficient state information to calculate things like availability. <br><br>0 = Disable logging current state after log rotation<br>1 = Enable logging current state after log rotation (default).');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'check_workers', 'This setting specifies how many worker process should be started when Nagios Core starts. Worker processes are used to perform host and service checks. If the number of workers is not specified, a default number of workers is determined based on the number of CPU cores on the system (1.5 workers per core). If not specified, there is always a minimum of 4 workers.');
REPLACE INTO `label`(section, name, label)  VALUES('nagios_main_desc', 'query_socket', 'This is the path to the Unix-domain socket used by the <a href="http://nagios.sourceforge.net/docs/nagioscore/4/en/whatsnew.html#qh">query handler</a> interface. The default value is /usr/local/nagios/var/rw/nagios.qh.');